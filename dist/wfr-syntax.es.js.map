{"version":3,"file":"wfr-syntax.es.js","sources":["../src/wfr-parser.js","../src/wfr-render.js","../src/wfr-matcher.js"],"sourcesContent":["// --- WebFeatureRules Parser ---\n\nconst tokenPatterns = [\n  { type: \"comment\", pattern: /^\\/\\/.*(?:\\n|$)/ },\n  { type: \"comment-start\", pattern: /^\\/\\*/ },\n  { type: \"comment-end\", pattern: /^\\*\\// },\n  { type: \"comment-content\", pattern: /^(?:[^\\*]+|\\*(?!\\/))/ },\n  { type: \"selector-bracket\", pattern: /^[\\[\\]]/ },\n  { type: \"selector-attribute\", pattern: /^[\\w.]*(?=\\s*(?:=|\\]))/ },\n  { type: \"selector-operator\", pattern: /^=/ },\n  { type: \"selector-regex-prefix\", pattern: /^(regex:|re:|[:$])/ },\n  { type: \"selector-regex-pattern\", pattern: /^\\/[^]*?(?=[\\[\\]\\s,{}])/ }, // Updated: Match until boundary\n  { type: \"selector-value\", pattern: /^(?:\"[^\"]*\"|'[^']*'|[^,\\s\\[\\]{}]+)/ },\n  { type: \"block-bracket\", pattern: /^[\\{\\}]/ },\n  { type: \"feature-name\", pattern: /^[\\w-]+(?=\\s*:)/ },\n  { type: \"feature-colon\", pattern: /^:/ },\n  { type: \"feature-value\", pattern: /^(?:on|off|\\d+(?:\\.\\d+)?(?:px|em|rem|%)?|\"[^\"]*\"|'[^']*')(?=\\s*;)/ },\n  { type: \"feature-semicolon\", pattern: /^;/ },\n  { type: \"comma\", pattern: /^,/ },\n  { type: \"whitespace\", pattern: /^\\s+/ },\n  { type: \"unknown\", pattern: /^./ },\n];\n\nconst validAttributeNames = [\"host\", \"domain\", \"path\", \"query\"];\n\nconst tokenTypes = {\n  \"comment\": 4,\n  \"comment-start\": 4,\n  \"comment-end\": 1 | 2 | 4,\n  \"comment-content\": 1 | 2 | 4,\n  \"whitespace\": 1 | 4,\n  \"selector-value\": 8,\n  \"selector-regex-pattern\": 8\n};\n\nexport function parseRules(wfrText) {\n  let rules = [];\n  const tokens = tokenize(wfrText);\n  processTokens(tokens, rules);\n  console.log(213, rules)\n  return rules.filter(\n    (rule) => rule.selectors.some((s) => s.length > 0) && Object.keys(rule.features).length > 0\n  );\n}\n\nexport function tokenize(text) {\n  const tokens = [];\n  let pos = 0;\n  const state = { inSelector: false, inBlock: false, inMultiLineComment: false, afterRegexPrefix: false, afterSelectorOperator: false, expectingAttribute: false };\n\n  while (pos < text.length) {\n    const slice = text.slice(pos);\n    let matched = false;\n    for (const { type, pattern } of tokenPatterns) {\n      if (!shouldProcessToken(type, state)) continue;\n      const match = slice.match(pattern);\n      if (match) {\n        const text = match[0];\n        updateState(type, text, state);\n        tokens.push({ type, text, state: { ...state } });\n        pos += text.length;\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      tokens.push({ type: \"unknown\", text: slice[0], state: { ...state } });\n      pos++;\n    }\n  }\n  return tokens;\n}\n\nfunction shouldProcessToken(type, state) {\n  if (state.inMultiLineComment && !((tokenTypes[type] & 1) === 1)) return false;\n  if (!state.inMultiLineComment && ((tokenTypes[type] & 2) === 2)) return false;\n  if (type === \"selector-value\" && !state.afterSelectorOperator) return false;\n  if (type === \"selector-regex-prefix\" && state.inBlock) return false;\n  if (type === \"feature-colon\" && !state.inBlock) return false;\n  if (type === \"selector-attribute\" && !state.expectingAttribute) return false;\n  if (type === \"selector-regex-pattern\" && !state.afterRegexPrefix) return false;\n  // Allow selector to end after regex prefix without a pattern\n  if (state.afterRegexPrefix && type !== \"selector-regex-pattern\" && type !== \"whitespace\" && type !== \"selector-bracket\") return false;\n  if (type !== \"whitespace\" && type !== \"selector-attribute\" && state.expectingAttribute) return false;\n  return true;\n}\n\nfunction updateState(type, text, state) {\n  if (type === \"comment-start\") state.inMultiLineComment = true;\n  else if (type === \"comment-end\") state.inMultiLineComment = false;\n  else if (type === \"selector-bracket\") {\n    state.inSelector = text === \"[\";\n    state.afterSelectorOperator = false;\n    state.expectingAttribute = text === \"[\";\n    if (text === \"]\") {\n      state.expectingAttribute = false; // Reset when closing\n      state.afterRegexPrefix = false;\n    }\n  } else if (type === \"block-bracket\") {\n    state.inBlock = text === \"{\";\n    if (text === \"{\") state.inSelector = false;\n    state.afterRegexPrefix = false;\n    state.expectingAttribute = false;\n  } else if (type === \"selector-operator\") state.afterSelectorOperator = true;\n  else if (type === \"selector-regex-prefix\") state.afterRegexPrefix = true;\n  else if (type === \"selector-value\" || type === \"selector-regex-pattern\") {\n    state.afterSelectorOperator = false;\n    state.afterRegexPrefix = false;\n  } else if (type === \"selector-attribute\") state.expectingAttribute = false;\n}\n\nfunction processTokens(tokens, rules) {\n  let currentRule = null, currentSelector = null, currentFeature = null, inMultiLineComment = false, inBlock = false;\n  for (const token of tokens) {\n    if (isCommentToken(token.type)) {\n      inMultiLineComment = token.type === \"comment-start\" ? true : token.type === \"comment-end\" ? false : inMultiLineComment;\n      continue;\n    }\n    if (inMultiLineComment) continue;\n    handleToken(token, { currentRule, currentSelector, currentFeature, inBlock }, (state) => {\n      currentRule = state.currentRule;\n      currentSelector = state.currentSelector;\n      currentFeature = state.currentFeature;\n      inBlock = state.inBlock;\n    });\n    if (currentRule && !rules.includes(currentRule)) rules.push(currentRule);\n  }\n}\n\nfunction isCommentToken(type) {\n  return ((tokenTypes[type] & 4) === 4);\n}\n\nfunction handleToken(token, state, updateState) {\n  if (token.type === \"selector-bracket\" && token.text === \"[\") {\n    if (!state.currentRule || state.inBlock) {\n      const selectors = [[]], features = {};\n      state.currentSelector = selectors[0];\n      state.currentRule = { selectors, features };\n    } else {\n      state.currentRule.selectors.push(state.currentSelector = []);\n    }\n    state.currentSelector.push({ attribute: \"\", operator: \"\", value: \"\", isRegex: false });\n  } else if (token.type === \"selector-attribute\" && state.currentSelector) {\n    const condition = state.currentSelector[state.currentSelector.length - 1];\n    condition.attribute = token.text;\n    if (state.currentSelector.length > 0 && token.state.expectingAttribute && !token.state.afterSelectorOperator) {\n      condition.operator = \"exists\";\n      condition.value = null;\n    }\n  } else if (token.type === \"selector-operator\" && state.currentSelector) {\n    state.currentSelector[state.currentSelector.length - 1].operator = token.text;\n  } else if (token.type === \"selector-regex-prefix\" && state.currentSelector) {\n    state.currentSelector[state.currentSelector.length - 1].isRegex = true;\n    state.currentSelector[state.currentSelector.length - 1].value = \"\"; // Default empty until pattern\n  } else if (((tokenTypes[token.type] & 8) === 8) && state.currentSelector) {\n    const condition = state.currentSelector[state.currentSelector.length - 1];\n    condition.value = token.text; // Exact text from token (e.g., \"/\")\n    if (token.type === \"selector-regex-pattern\") condition.isRegex = true;\n  } else if (token.type === \"block-bracket\") {\n    state.inBlock = token.text === \"{\";\n    if (token.text === \"}\") {\n      state.currentRule = null;\n      state.currentSelector = null;\n    }\n  } else if (token.type === \"feature-name\" && state.inBlock && state.currentRule) {\n    state.currentFeature = token.text;\n  } else if (token.type === \"feature-value\" && state.inBlock && state.currentRule && state.currentFeature) {\n    state.currentRule.features[state.currentFeature] = token.text.replace(/^(\"|')|(\"|')$/g, \"\");\n  }\n  updateState(state);\n}\n\nexport function getFeatureValues(rules, url) {\n  const parsedUrl = new URL(url);\n  const featureValues = {};\n  rules.sort((a, b) => Math.max(...a.selectors.map((s) => s.length)) - Math.max(...b.selectors.map((s) => s.length))).forEach((rule) => {\n    if (ruleMatchesUrl(rule, parsedUrl)) Object.assign(featureValues, rule.features);\n  });\n  return featureValues;\n}\n\nfunction ruleMatchesUrl(rule, parsedUrl) {\n  return rule.selectors.some((selectorGroup) => selectorGroup.every((condition) => conditionMatchesUrl(condition, parsedUrl)));\n}\n\nfunction conditionMatchesUrl(condition, parsedUrl) {\n  if (!condition.attribute || !parsedUrl) return false;\n  if (condition.operator === \"exists\" && condition.attribute.startsWith(\"query.\")) {\n    return parsedUrl.searchParams.has(condition.attribute.substring(6));\n  }\n  const attrValue = getAttrValue(condition.attribute, parsedUrl);\n  if (attrValue === null) return false;\n  if (condition.attribute === \"domain\" && condition.value === \"*\" && !condition.isRegex) return true;\n  return condition.isRegex ? matchRegex(attrValue, condition.value) :\n    condition.attribute === \"domain\" && !/[?*]/.test(condition.value) ?\n      attrValue === condition.value || attrValue.endsWith(\".\" + condition.value) :\n      matchGlob(attrValue, condition.value);\n}\n\nfunction getAttrValue(attribute, parsedUrl) {\n  return attribute === \"host\" || attribute === \"domain\" ? parsedUrl.hostname || \"\" :\n    attribute === \"path\" ? parsedUrl.pathname || \"\" :\n      attribute.startsWith(\"query.\") ? parsedUrl.searchParams.get(attribute.substring(6)) || null : null;\n}\n\nfunction matchRegex(attrValue, pattern) {\n  if (!attrValue || !pattern) return false;\n  try {\n    const [, regexPattern, flags] = pattern.match(/^\\/(.*)\\/([a-z]*)$/) || [null, pattern, \"\"];\n    if (!regexPattern) throw new Error(\"Incomplete regex pattern\");\n    return new RegExp(regexPattern, flags).test(attrValue);\n  } catch (e) {\n    console.warn(\"Invalid regex pattern:\", pattern, e);\n    return false;\n  }\n}\n\nfunction matchGlob(attrValue, pattern) {\n  if (!attrValue || !pattern) return false;\n  try {\n    const regexPattern = pattern.replace(/[.+^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/\\?/g, \".\");\n    return new RegExp(\"^\" + regexPattern + \"$\").test(attrValue);\n  } catch (e) {\n    console.warn(\"Invalid glob pattern:\", pattern, e);\n    return false;\n  }\n}","import { tokenize } from './wfr-parser.js';\n\n// Enhanced patterns for internal regex highlighting\nconst REGEX_INTERNAL_PATTERNS = [\n    { type: 'regex-escape', pattern: /^\\\\[\\\\\\/\\[\\](){}|.^$*+?]/ },\n    { type: 'regex-char-class-escape', pattern: /^\\\\[wWdDsS]/ },\n    { type: 'regex-anchor', pattern: /^[\\^$]|\\\\b|\\\\B/ },\n    { type: 'regex-punctuation', pattern: /^[()[\\]]/ },\n    { type: 'regex-alternation', pattern: /^\\|/ },\n    { type: 'regex-punctuation', pattern: /^[{}]/ },\n    { type: 'regex-quantifier', pattern: /^[?*+]/ },\n    { type: 'regex-punctuation', pattern: /^\\./ },\n    { type: 'regex-literal', pattern: /^[^\\\\\\s\\/\\[\\](){}|.^$*+?]+/ },\n    { type: 'unknown', pattern: /^./ }\n];\n\n// Tokenize internal regex pattern with nesting support\nconst tokenizeRegexPattern = (pattern) => {\n    const tokens = [];\n    let pos = 0;\n    const stack = [];\n\n    while (pos < pattern.length) {\n        const slice = pattern.slice(pos);\n        let matched = false;\n\n        // Handle closing brackets in nested contexts\n        if (stack.length > 0 && (slice[0] === ']' || slice[0] === '}')) {\n            const top = stack[stack.length - 1];\n            if ((top.opener === '[' && slice[0] === ']') || (top.opener === '{' && slice[0] === '}')) {\n                tokens.push({ type: 'regex-punctuation', text: slice[0] });\n                stack.pop();\n                // Adjust for quantifiers like {1,2}\n                if (\n                    tokens.length >= 2 &&\n                    tokens[tokens.length - 2].type === 'regex-punctuation' &&\n                    tokens[tokens.length - 2].text === '{'\n                ) {\n                    const content = tokens[tokens.length - 1].text;\n                    if (content.match(/^\\d+(?:,\\d*)?$/)) {\n                        tokens[tokens.length - 2] = { type: 'regex-punctuation', text: '{' };\n                        tokens[tokens.length - 1] = { type: 'regex-quantifier', text: content };\n                        tokens[tokens.length] = { type: 'regex-punctuation', text: '}' };\n                    }\n                }\n                pos++;\n                matched = true;\n            }\n        }\n\n        // Match patterns if no closing bracket\n        if (!matched) {\n            for (const { type, pattern: pat } of REGEX_INTERNAL_PATTERNS) {\n                const match = slice.match(pat);\n                if (match) {\n                    const text = match[0];\n                    if (type === 'regex-punctuation' && (text === '[' || text === '{')) {\n                        stack.push({ opener: text, closer: text === '[' ? ']' : '}' });\n                    }\n                    tokens.push({ type, text });\n                    pos += text.length;\n                    matched = true;\n                    break;\n                }\n            }\n        }\n\n        // Fallback for unmatched characters\n        if (!matched) {\n            tokens.push({ type: 'unknown', text: slice[0] });\n            pos++;\n        }\n    }\n\n    // Append closing brackets for unclosed structures\n    while (stack.length > 0) {\n        tokens.push({ type: 'regex-punctuation', text: stack.pop().closer });\n    }\n\n    return tokens;\n};\n\n// Render regex pattern as a document fragment\nconst renderRegexPattern = (text) => {\n    const fragment = document.createDocumentFragment();\n\n    // If text doesn’t start with '/', treat it as plain text\n    if (!text.startsWith('/')) {\n        fragment.appendChild(document.createTextNode(text));\n        return fragment;\n    }\n\n    // Render the opening '/' for regex patterns\n    const openingSlash = document.createElement('span');\n    openingSlash.className = 'wfr-regex-punctuation';\n    openingSlash.textContent = '/';\n    fragment.appendChild(openingSlash);\n\n    // Extract content after the opening '/'\n    let patternText = text.slice(1);\n    let flag = '';\n    let hasClosingSlash = false;\n    let inner = patternText;\n\n    // Check for a flag (e.g., '/i')\n    if (patternText.endsWith('/i')) {\n        flag = 'i';\n        inner = patternText.slice(0, -2); // Remove '/i' to get inner content\n        hasClosingSlash = true;\n    }\n    // Check for a closing '/' without a flag\n    else if (patternText.endsWith('/')) {\n        inner = patternText.slice(0, -1); // Remove '/' to get inner content\n        hasClosingSlash = true;\n    }\n    // If neither, inner is the full patternText (incomplete pattern)\n\n    // Tokenize the inner content\n    const tokens = tokenizeRegexPattern(inner);\n    tokens.forEach((token) => {\n        const span = document.createElement('span');\n        span.className = `wfr-${token.type}`;\n        span.textContent = token.text;\n        fragment.appendChild(span);\n    });\n\n    // Add closing '/' only if it’s in the input\n    if (hasClosingSlash) {\n        const closingSlash = document.createElement('span');\n        closingSlash.className = 'wfr-regex-punctuation';\n        closingSlash.textContent = '/';\n        fragment.appendChild(closingSlash);\n    }\n\n    // Add flag if present\n    if (flag) {\n        const flagSpan = document.createElement('span');\n        flagSpan.className = 'wfr-regex-flag';\n        flagSpan.textContent = flag;\n        fragment.appendChild(flagSpan);\n    }\n\n    return fragment;\n};\n\n// Convert tokens to a document fragment\nexport function tokensToFragment(tokens) {\n    const fragment = document.createDocumentFragment();\n    tokens.forEach((token) => {\n        if (token.type === 'whitespace') {\n            fragment.appendChild(document.createTextNode(token.text));\n        } else if (token.type === 'selector-regex-pattern' || token.type === 'feature-regex') {\n            console.log(122, token.text, renderRegexPattern(token.text))\n            fragment.appendChild(renderRegexPattern(token.text));\n        } else {\n            const span = document.createElement('span');\n            let className = `wfr-${token.type}`;\n            if (token.type.startsWith('comment')) className += ' wfr-comment';\n            if (token.type === 'selector-regex-prefix') className += ' wfr-regex-prefix';\n            span.className = className;\n            span.textContent = token.text;\n            fragment.appendChild(span);\n        }\n    });\n\n    return fragment;\n};\n\nexport function highlight(editor) {\n    const code = editor.textContent;\n    try {\n        const tokens = tokenize(code);\n        const fragment = tokensToFragment(tokens);\n        editor.replaceChildren(fragment);\n    } catch (error) {\n        console.error('WFR highlighting error:', error);\n        editor.textContent = code;\n    }\n}","// Glob Matching\nfunction matchGlob(p, s) {\n    const firstWild = Math.min(p.indexOf('*') + 1 || Infinity, p.indexOf('?') + 1 || Infinity) - 1;\n    if (firstWild >= Infinity) return p === s;\n    if (firstWild > 0 && !s.startsWith(p.substring(0, firstWild))) return false;\n\n    const n = p.length, m = s.length;\n    let top = 0;\n    const stack = new Array(m - firstWild + 1);\n    stack[0] = { i: firstWild, j: firstWild };\n\n    while (top >= 0) {\n        let { i, j } = stack[top--];\n        while (i < n && p.charCodeAt(i) !== 42 && p.charCodeAt(i) !== 63) {\n            if (j >= m || p.charCodeAt(i) !== s.charCodeAt(j)) break;\n            i++; j++;\n        }\n        if (i === n) {\n            if (j === m) return true;\n            continue;\n        }\n\n        let c = p.charCodeAt(i);\n        if (c === 42) {\n            if (i + 1 < n && p.charCodeAt(i + 1) === 42) {\n                i += 2;\n                if (i >= n) return true;\n                for (let x = m; x >= j; x--) {\n                    stack[++top] = { i, j: x };\n                }\n            } else {\n                i++;\n                let end = j;\n                while (end < m && s.charCodeAt(end) !== 47 && s.charCodeAt(end) !== 46) end++;\n                if (i === n) {\n                    if (end === m) return true;\n                    continue;\n                }\n                for (let x = end; x >= j; x--) {\n                    stack[++top] = { i, j: x };\n                }\n            }\n        } else if (c === 63) {\n            if (j < m && s.charCodeAt(j) !== 47 && s.charCodeAt(j) !== 46) {\n                stack[++top] = { i: i + 1, j: j + 1 };\n            }\n        }\n    }\n    return false;\n}\n\n// Parse Regex\nfunction parseRegex(value) {\n    if (typeof value !== 'string') return null;\n    const offset = value.indexOf('/');\n    if (offset === 6 && value.startsWith(\"regex:\")) {\n    } else if (offset === 3 && value.startsWith(\"re:\")) {\n    } else if (offset === 1 && (value[0] === ':' || value[0] === '$')) {\n    } else {\n        return null;\n    }\n    const start = offset + 1;\n    const end = value.lastIndexOf('/');\n    if (end <= start) return null;\n    const patternStr = value.slice(start, end);\n    const flags = value.slice(end + 1);\n    try {\n        return new RegExp(patternStr, flags);\n    } catch (e) {\n        return null;\n    }\n}\n\n// Tokenize\nfunction tokenize(text) {\n    const tokens = [];\n    for (let i = 0, len = text.length; i < len;) {\n        let c = text[i];\n        if (c <= ' ') { i++; continue; }\n        if (c === '/') {\n            if (text[i + 1] === '/') { i = (text.indexOf('\\n', i + 2) + 1) || len; continue; }\n            if (text[i + 1] === '*') { i = ((text.indexOf('*/', i + 2) + 1) || len + 1); continue; }\n        } else if ('[]{}:;,'.includes(c)) { tokens.push(c); i++; continue; }\n        else if (c === '=') {\n            tokens.push('=');\n            i++;\n            let slashPos = text.indexOf('/', i);\n            if (slashPos > i && slashPos < i + 8) {\n                const regexMatch = text.slice(i).match(/^(?:regex:|re:|[:$])\\/.*?(?:\\/[a-z]*)?(?=[\\s\\]\\},;]|$)/i);\n                if (regexMatch) { tokens.push(regexMatch[0]); i += regexMatch[0].length; continue; }\n            }\n        }\n        const start = i;\n        while (i < len && text[i] > ' ' && !'[]{}:;,='.includes(text[i])) i++;\n        if (i > start) tokens.push(text.slice(start, i));\n    }\n    return tokens;\n}\n\n// Parse Rules\nfunction parseRules(text) {\n    const tokens = tokenize(text), rules = [];\n    for (let i = 0, len = tokens.length; i < len;) {\n        if (tokens[i] === '[') {\n            const groups = [[]];\n            try {\n                while (i < len && tokens[i] !== '{') {\n                    if (tokens[i] === '[') {\n                        const attr = tokens[++i]; i++;\n                        if (!attr) throw new Error('Missing attribute');\n                        let value = null, isRegex = false;\n                        if (tokens[i] === '=') {\n                            value = tokens[++i]; i++;\n                            const rx = parseRegex(value);\n                            if (rx) { value = rx; isRegex = true; }\n                        } else if (!attr.startsWith('query.')) throw new Error('Expected \"=\"');\n                        if (tokens[i++] !== ']') throw new Error('Missing \"]\"');\n                        groups[groups.length - 1].push({ attr, value, isRegex });\n                    } else if (tokens[i] === ',') {\n                        groups.push([]);\n                        i++;\n                    } else throw new Error('Invalid selector');\n                }\n                if (tokens[i++] !== '{') throw new Error('Missing \"{\"');\n                const features = {};\n                while (i < len && tokens[i] !== '}') {\n                    const name = tokens[i++], colon = tokens[i++], value = tokens[i++], semi = tokens[i++];\n                    if (colon !== ':' || semi !== ';') throw new Error('Invalid feature');\n                    features[name] = value;\n                }\n                if (tokens[i++] !== '}') throw new Error('Missing \"}\"');\n                rules.push({ selectors: groups.filter(g => g.length), features });\n            } catch (e) {\n                while (i < len && tokens[i] !== '[') i++;\n            }\n        } else i++;\n    }\n    return rules;\n}\n\n// Match Condition\nfunction matchCondition({ attr, value, isRegex }, { host, pathname, searchParams }) {\n    if (attr === 'host') return isRegex ? value.test(host) : matchGlob(value, host);\n    if (attr === 'path') return isRegex ? value.test(pathname) : matchGlob(value, pathname);\n    if (attr === 'domain') {\n        const domain = host.split('.').slice(-2).join('.');\n        return isRegex ? value.test(host) : matchGlob(value, domain);\n    }\n    if (attr.startsWith('query.')) {\n        const param = searchParams.get(attr.slice(6));\n        return value === null ? param !== null : param && (isRegex ? value.test(param) : matchGlob(value, param));\n    }\n    return false;\n}\n\n// Apply Rules\nfunction getFeatureValues(rules, urlObj) {\n    const features = {};\n    for (const rule of rules) {\n        if (rule.selectors.some(group => group.every(cond => matchCondition(cond, urlObj)))) {\n            Object.assign(features, rule.features);\n        }\n    }\n    return features;\n}\n\n// Export as ES Module\nexport function getWfrFeatures(text, url) {\n    try {\n        const urlObj = new URL(url);\n        return getFeatureValues(parseRules(text), urlObj);\n    } catch (_) {\n        return {};\n    }\n}"],"names":["tokenPatterns","tokenTypes","tokenize","text","tokens","pos","state","slice","matched","type","pattern","shouldProcessToken","match","updateState","REGEX_INTERNAL_PATTERNS","tokenizeRegexPattern","stack","top","content","pat","renderRegexPattern","fragment","openingSlash","patternText","flag","hasClosingSlash","inner","token","span","closingSlash","flagSpan","tokensToFragment","className","highlight","editor","code","error","matchGlob","p","s","firstWild","n","m","i","j","c","x","end","parseRegex","value","offset","start","patternStr","flags","e","len","slashPos","regexMatch","parseRules","rules","groups","attr","isRegex","rx","features","name","colon","semi","g","matchCondition","host","pathname","searchParams","domain","param","getFeatureValues","urlObj","rule","group","cond","getWfrFeatures","url","_"],"mappings":"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"}