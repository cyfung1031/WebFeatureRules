{"version":3,"file":"wfr-syntax.iife.js","sources":["../src/wfr-parser.js","../src/wfr-render.js","../src/wfr-matcher.js"],"sourcesContent":["// --- WebFeatureRules Parser ---\n\nconst tokenPatterns = [\n  { type: \"comment\", pattern: /^\\/\\/.*(?:\\n|$)/ },\n  { type: \"comment-start\", pattern: /^\\/\\*/ },\n  { type: \"comment-end\", pattern: /^\\*\\// },\n  { type: \"comment-content\", pattern: /^(?:[^\\*]+|\\*(?!\\/))/ },\n  { type: \"selector-bracket\", pattern: /^[\\[\\]]/ },\n  { type: \"selector-attribute\", pattern: /^[\\w.]*(?=\\s*(?:=|\\]))/ },\n  { type: \"selector-operator\", pattern: /^=/ },\n  { type: \"selector-regex-prefix\", pattern: /^(regex:|re:|[:$])/ },\n  { type: \"selector-regex-pattern\", pattern: /^\\/[^]*?(?=[\\[\\]\\s,{}])/ }, // Updated: Match until boundary\n  { type: \"selector-value\", pattern: /^(?:\"[^\"]*\"|'[^']*'|[^,\\s\\[\\]{}]+)/ },\n  { type: \"block-bracket\", pattern: /^[\\{\\}]/ },\n  { type: \"feature-name\", pattern: /^[\\w-]+(?=\\s*:)/ },\n  { type: \"feature-colon\", pattern: /^:/ },\n  { type: \"feature-value\", pattern: /^(?:on|off|\\d+(?:\\.\\d+)?(?:px|em|rem|%)?|\"[^\"]*\"|'[^']*')(?=\\s*;)/ },\n  { type: \"feature-semicolon\", pattern: /^;/ },\n  { type: \"comma\", pattern: /^,/ },\n  { type: \"whitespace\", pattern: /^\\s+/ },\n  { type: \"unknown\", pattern: /^./ },\n];\n\nconst validAttributeNames = [\"host\", \"domain\", \"path\", \"query\"];\n\nconst tokenTypes = {\n  \"comment\": 4,\n  \"comment-start\": 4,\n  \"comment-end\": 1 | 2 | 4,\n  \"comment-content\": 1 | 2 | 4,\n  \"whitespace\": 1 | 4,\n  \"selector-value\": 8,\n  \"selector-regex-pattern\": 8\n};\n\nexport function parseRules(wfrText) {\n  let rules = [];\n  const tokens = tokenize(wfrText);\n  processTokens(tokens, rules);\n  console.log(213, rules)\n  return rules.filter(\n    (rule) => rule.selectors.some((s) => s.length > 0) && Object.keys(rule.features).length > 0\n  );\n}\n\nexport function tokenize(text) {\n  const tokens = [];\n  let pos = 0;\n  const state = { inSelector: false, inBlock: false, inMultiLineComment: false, afterRegexPrefix: false, afterSelectorOperator: false, expectingAttribute: false };\n\n  while (pos < text.length) {\n    const slice = text.slice(pos);\n    let matched = false;\n    for (const { type, pattern } of tokenPatterns) {\n      if (!shouldProcessToken(type, state)) continue;\n      const match = slice.match(pattern);\n      if (match) {\n        const text = match[0];\n        updateState(type, text, state);\n        tokens.push({ type, text, state: { ...state } });\n        pos += text.length;\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      tokens.push({ type: \"unknown\", text: slice[0], state: { ...state } });\n      pos++;\n    }\n  }\n  return tokens;\n}\n\nfunction shouldProcessToken(type, state) {\n  if (state.inMultiLineComment && !((tokenTypes[type] & 1) === 1)) return false;\n  if (!state.inMultiLineComment && ((tokenTypes[type] & 2) === 2)) return false;\n  if (type === \"selector-value\" && !state.afterSelectorOperator) return false;\n  if (type === \"selector-regex-prefix\" && state.inBlock) return false;\n  if (type === \"feature-colon\" && !state.inBlock) return false;\n  if (type === \"selector-attribute\" && !state.expectingAttribute) return false;\n  if (type === \"selector-regex-pattern\" && !state.afterRegexPrefix) return false;\n  // Allow selector to end after regex prefix without a pattern\n  if (state.afterRegexPrefix && type !== \"selector-regex-pattern\" && type !== \"whitespace\" && type !== \"selector-bracket\") return false;\n  if (type !== \"whitespace\" && type !== \"selector-attribute\" && state.expectingAttribute) return false;\n  return true;\n}\n\nfunction updateState(type, text, state) {\n  if (type === \"comment-start\") state.inMultiLineComment = true;\n  else if (type === \"comment-end\") state.inMultiLineComment = false;\n  else if (type === \"selector-bracket\") {\n    state.inSelector = text === \"[\";\n    state.afterSelectorOperator = false;\n    state.expectingAttribute = text === \"[\";\n    if (text === \"]\") {\n      state.expectingAttribute = false; // Reset when closing\n      state.afterRegexPrefix = false;\n    }\n  } else if (type === \"block-bracket\") {\n    state.inBlock = text === \"{\";\n    if (text === \"{\") state.inSelector = false;\n    state.afterRegexPrefix = false;\n    state.expectingAttribute = false;\n  } else if (type === \"selector-operator\") state.afterSelectorOperator = true;\n  else if (type === \"selector-regex-prefix\") state.afterRegexPrefix = true;\n  else if (type === \"selector-value\" || type === \"selector-regex-pattern\") {\n    state.afterSelectorOperator = false;\n    state.afterRegexPrefix = false;\n  } else if (type === \"selector-attribute\") state.expectingAttribute = false;\n}\n\nfunction processTokens(tokens, rules) {\n  let currentRule = null, currentSelector = null, currentFeature = null, inMultiLineComment = false, inBlock = false;\n  for (const token of tokens) {\n    if (isCommentToken(token.type)) {\n      inMultiLineComment = token.type === \"comment-start\" ? true : token.type === \"comment-end\" ? false : inMultiLineComment;\n      continue;\n    }\n    if (inMultiLineComment) continue;\n    handleToken(token, { currentRule, currentSelector, currentFeature, inBlock }, (state) => {\n      currentRule = state.currentRule;\n      currentSelector = state.currentSelector;\n      currentFeature = state.currentFeature;\n      inBlock = state.inBlock;\n    });\n    if (currentRule && !rules.includes(currentRule)) rules.push(currentRule);\n  }\n}\n\nfunction isCommentToken(type) {\n  return ((tokenTypes[type] & 4) === 4);\n}\n\nfunction handleToken(token, state, updateState) {\n  if (token.type === \"selector-bracket\" && token.text === \"[\") {\n    if (!state.currentRule || state.inBlock) {\n      const selectors = [[]], features = {};\n      state.currentSelector = selectors[0];\n      state.currentRule = { selectors, features };\n    } else {\n      state.currentRule.selectors.push(state.currentSelector = []);\n    }\n    state.currentSelector.push({ attribute: \"\", operator: \"\", value: \"\", isRegex: false });\n  } else if (token.type === \"selector-attribute\" && state.currentSelector) {\n    const condition = state.currentSelector[state.currentSelector.length - 1];\n    condition.attribute = token.text;\n    if (state.currentSelector.length > 0 && token.state.expectingAttribute && !token.state.afterSelectorOperator) {\n      condition.operator = \"exists\";\n      condition.value = null;\n    }\n  } else if (token.type === \"selector-operator\" && state.currentSelector) {\n    state.currentSelector[state.currentSelector.length - 1].operator = token.text;\n  } else if (token.type === \"selector-regex-prefix\" && state.currentSelector) {\n    state.currentSelector[state.currentSelector.length - 1].isRegex = true;\n    state.currentSelector[state.currentSelector.length - 1].value = \"\"; // Default empty until pattern\n  } else if (((tokenTypes[token.type] & 8) === 8) && state.currentSelector) {\n    const condition = state.currentSelector[state.currentSelector.length - 1];\n    condition.value = token.text; // Exact text from token (e.g., \"/\")\n    if (token.type === \"selector-regex-pattern\") condition.isRegex = true;\n  } else if (token.type === \"block-bracket\") {\n    state.inBlock = token.text === \"{\";\n    if (token.text === \"}\") {\n      state.currentRule = null;\n      state.currentSelector = null;\n    }\n  } else if (token.type === \"feature-name\" && state.inBlock && state.currentRule) {\n    state.currentFeature = token.text;\n  } else if (token.type === \"feature-value\" && state.inBlock && state.currentRule && state.currentFeature) {\n    state.currentRule.features[state.currentFeature] = token.text.replace(/^(\"|')|(\"|')$/g, \"\");\n  }\n  updateState(state);\n}\n\nexport function getFeatureValues(rules, url) {\n  const parsedUrl = new URL(url);\n  const featureValues = {};\n  rules.sort((a, b) => Math.max(...a.selectors.map((s) => s.length)) - Math.max(...b.selectors.map((s) => s.length))).forEach((rule) => {\n    if (ruleMatchesUrl(rule, parsedUrl)) Object.assign(featureValues, rule.features);\n  });\n  return featureValues;\n}\n\nfunction ruleMatchesUrl(rule, parsedUrl) {\n  return rule.selectors.some((selectorGroup) => selectorGroup.every((condition) => conditionMatchesUrl(condition, parsedUrl)));\n}\n\nfunction conditionMatchesUrl(condition, parsedUrl) {\n  if (!condition.attribute || !parsedUrl) return false;\n  if (condition.operator === \"exists\" && condition.attribute.startsWith(\"query.\")) {\n    return parsedUrl.searchParams.has(condition.attribute.substring(6));\n  }\n  const attrValue = getAttrValue(condition.attribute, parsedUrl);\n  if (attrValue === null) return false;\n  if (condition.attribute === \"domain\" && condition.value === \"*\" && !condition.isRegex) return true;\n  return condition.isRegex ? matchRegex(attrValue, condition.value) :\n    condition.attribute === \"domain\" && !/[?*]/.test(condition.value) ?\n      attrValue === condition.value || attrValue.endsWith(\".\" + condition.value) :\n      matchGlob(attrValue, condition.value);\n}\n\nfunction getAttrValue(attribute, parsedUrl) {\n  return attribute === \"host\" || attribute === \"domain\" ? parsedUrl.hostname || \"\" :\n    attribute === \"path\" ? parsedUrl.pathname || \"\" :\n      attribute.startsWith(\"query.\") ? parsedUrl.searchParams.get(attribute.substring(6)) || null : null;\n}\n\nfunction matchRegex(attrValue, pattern) {\n  if (!attrValue || !pattern) return false;\n  try {\n    const [, regexPattern, flags] = pattern.match(/^\\/(.*)\\/([a-z]*)$/) || [null, pattern, \"\"];\n    if (!regexPattern) throw new Error(\"Incomplete regex pattern\");\n    return new RegExp(regexPattern, flags).test(attrValue);\n  } catch (e) {\n    console.warn(\"Invalid regex pattern:\", pattern, e);\n    return false;\n  }\n}\n\nfunction matchGlob(attrValue, pattern) {\n  if (!attrValue || !pattern) return false;\n  try {\n    const regexPattern = pattern.replace(/[.+^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/\\?/g, \".\");\n    return new RegExp(\"^\" + regexPattern + \"$\").test(attrValue);\n  } catch (e) {\n    console.warn(\"Invalid glob pattern:\", pattern, e);\n    return false;\n  }\n}","import { tokenize } from './wfr-parser.js';\n\n// Enhanced patterns for internal regex highlighting\nconst REGEX_INTERNAL_PATTERNS = [\n    { type: 'regex-escape', pattern: /^\\\\[\\\\\\/\\[\\](){}|.^$*+?]/ },\n    { type: 'regex-char-class-escape', pattern: /^\\\\[wWdDsS]/ },\n    { type: 'regex-anchor', pattern: /^[\\^$]|\\\\b|\\\\B/ },\n    { type: 'regex-punctuation', pattern: /^[()[\\]]/ },\n    { type: 'regex-alternation', pattern: /^\\|/ },\n    { type: 'regex-punctuation', pattern: /^[{}]/ },\n    { type: 'regex-quantifier', pattern: /^[?*+]/ },\n    { type: 'regex-punctuation', pattern: /^\\./ },\n    { type: 'regex-literal', pattern: /^[^\\\\\\s\\/\\[\\](){}|.^$*+?]+/ },\n    { type: 'unknown', pattern: /^./ }\n];\n\n// Tokenize internal regex pattern with nesting support\nconst tokenizeRegexPattern = (pattern) => {\n    const tokens = [];\n    let pos = 0;\n    const stack = [];\n\n    while (pos < pattern.length) {\n        const slice = pattern.slice(pos);\n        let matched = false;\n\n        // Handle closing brackets in nested contexts\n        if (stack.length > 0 && (slice[0] === ']' || slice[0] === '}')) {\n            const top = stack[stack.length - 1];\n            if ((top.opener === '[' && slice[0] === ']') || (top.opener === '{' && slice[0] === '}')) {\n                tokens.push({ type: 'regex-punctuation', text: slice[0] });\n                stack.pop();\n                // Adjust for quantifiers like {1,2}\n                if (\n                    tokens.length >= 2 &&\n                    tokens[tokens.length - 2].type === 'regex-punctuation' &&\n                    tokens[tokens.length - 2].text === '{'\n                ) {\n                    const content = tokens[tokens.length - 1].text;\n                    if (content.match(/^\\d+(?:,\\d*)?$/)) {\n                        tokens[tokens.length - 2] = { type: 'regex-punctuation', text: '{' };\n                        tokens[tokens.length - 1] = { type: 'regex-quantifier', text: content };\n                        tokens[tokens.length] = { type: 'regex-punctuation', text: '}' };\n                    }\n                }\n                pos++;\n                matched = true;\n            }\n        }\n\n        // Match patterns if no closing bracket\n        if (!matched) {\n            for (const { type, pattern: pat } of REGEX_INTERNAL_PATTERNS) {\n                const match = slice.match(pat);\n                if (match) {\n                    const text = match[0];\n                    if (type === 'regex-punctuation' && (text === '[' || text === '{')) {\n                        stack.push({ opener: text, closer: text === '[' ? ']' : '}' });\n                    }\n                    tokens.push({ type, text });\n                    pos += text.length;\n                    matched = true;\n                    break;\n                }\n            }\n        }\n\n        // Fallback for unmatched characters\n        if (!matched) {\n            tokens.push({ type: 'unknown', text: slice[0] });\n            pos++;\n        }\n    }\n\n    // Append closing brackets for unclosed structures\n    while (stack.length > 0) {\n        tokens.push({ type: 'regex-punctuation', text: stack.pop().closer });\n    }\n\n    return tokens;\n};\n\n// Render regex pattern as a document fragment\nconst renderRegexPattern = (text) => {\n    const fragment = document.createDocumentFragment();\n\n    // If text doesn’t start with '/', treat it as plain text\n    if (!text.startsWith('/')) {\n        fragment.appendChild(document.createTextNode(text));\n        return fragment;\n    }\n\n    // Render the opening '/' for regex patterns\n    const openingSlash = document.createElement('span');\n    openingSlash.className = 'wfr-regex-punctuation';\n    openingSlash.textContent = '/';\n    fragment.appendChild(openingSlash);\n\n    // Extract content after the opening '/'\n    let patternText = text.slice(1);\n    let flag = '';\n    let hasClosingSlash = false;\n    let inner = patternText;\n\n    // Check for a flag (e.g., '/i')\n    if (patternText.endsWith('/i')) {\n        flag = 'i';\n        inner = patternText.slice(0, -2); // Remove '/i' to get inner content\n        hasClosingSlash = true;\n    }\n    // Check for a closing '/' without a flag\n    else if (patternText.endsWith('/')) {\n        inner = patternText.slice(0, -1); // Remove '/' to get inner content\n        hasClosingSlash = true;\n    }\n    // If neither, inner is the full patternText (incomplete pattern)\n\n    // Tokenize the inner content\n    const tokens = tokenizeRegexPattern(inner);\n    tokens.forEach((token) => {\n        const span = document.createElement('span');\n        span.className = `wfr-${token.type}`;\n        span.textContent = token.text;\n        fragment.appendChild(span);\n    });\n\n    // Add closing '/' only if it’s in the input\n    if (hasClosingSlash) {\n        const closingSlash = document.createElement('span');\n        closingSlash.className = 'wfr-regex-punctuation';\n        closingSlash.textContent = '/';\n        fragment.appendChild(closingSlash);\n    }\n\n    // Add flag if present\n    if (flag) {\n        const flagSpan = document.createElement('span');\n        flagSpan.className = 'wfr-regex-flag';\n        flagSpan.textContent = flag;\n        fragment.appendChild(flagSpan);\n    }\n\n    return fragment;\n};\n\n// Convert tokens to a document fragment\nexport function tokensToFragment(tokens) {\n    const fragment = document.createDocumentFragment();\n    tokens.forEach((token) => {\n        if (token.type === 'whitespace') {\n            fragment.appendChild(document.createTextNode(token.text));\n        } else if (token.type === 'selector-regex-pattern' || token.type === 'feature-regex') {\n            console.log(122, token.text, renderRegexPattern(token.text))\n            fragment.appendChild(renderRegexPattern(token.text));\n        } else {\n            const span = document.createElement('span');\n            let className = `wfr-${token.type}`;\n            if (token.type.startsWith('comment')) className += ' wfr-comment';\n            if (token.type === 'selector-regex-prefix') className += ' wfr-regex-prefix';\n            span.className = className;\n            span.textContent = token.text;\n            fragment.appendChild(span);\n        }\n    });\n\n    return fragment;\n};\n\nexport function highlight(editor) {\n    const code = editor.textContent;\n    try {\n        const tokens = tokenize(code);\n        const fragment = tokensToFragment(tokens);\n        editor.replaceChildren(fragment);\n    } catch (error) {\n        console.error('WFR highlighting error:', error);\n        editor.textContent = code;\n    }\n}","// Glob Matching\nfunction matchGlob(p, s) {\n    const firstWild = Math.min(p.indexOf('*') + 1 || Infinity, p.indexOf('?') + 1 || Infinity) - 1;\n    if (firstWild >= Infinity) return p === s;\n    if (firstWild > 0 && !s.startsWith(p.substring(0, firstWild))) return false;\n\n    const n = p.length, m = s.length;\n    let top = 0;\n    const stack = new Array(m - firstWild + 1);\n    stack[0] = { i: firstWild, j: firstWild };\n\n    while (top >= 0) {\n        let { i, j } = stack[top--];\n        while (i < n && p.charCodeAt(i) !== 42 && p.charCodeAt(i) !== 63) {\n            if (j >= m || p.charCodeAt(i) !== s.charCodeAt(j)) break;\n            i++; j++;\n        }\n        if (i === n) {\n            if (j === m) return true;\n            continue;\n        }\n\n        let c = p.charCodeAt(i);\n        if (c === 42) {\n            if (i + 1 < n && p.charCodeAt(i + 1) === 42) {\n                i += 2;\n                if (i >= n) return true;\n                for (let x = m; x >= j; x--) {\n                    stack[++top] = { i, j: x };\n                }\n            } else {\n                i++;\n                let end = j;\n                while (end < m && s.charCodeAt(end) !== 47 && s.charCodeAt(end) !== 46) end++;\n                if (i === n) {\n                    if (end === m) return true;\n                    continue;\n                }\n                for (let x = end; x >= j; x--) {\n                    stack[++top] = { i, j: x };\n                }\n            }\n        } else if (c === 63) {\n            if (j < m && s.charCodeAt(j) !== 47 && s.charCodeAt(j) !== 46) {\n                stack[++top] = { i: i + 1, j: j + 1 };\n            }\n        }\n    }\n    return false;\n}\n\n// Parse Regex\nfunction parseRegex(value) {\n    if (typeof value !== 'string') return null;\n    const offset = value.indexOf('/');\n    if (offset === 6 && value.startsWith(\"regex:\")) {\n    } else if (offset === 3 && value.startsWith(\"re:\")) {\n    } else if (offset === 1 && (value[0] === ':' || value[0] === '$')) {\n    } else {\n        return null;\n    }\n    const start = offset + 1;\n    const end = value.lastIndexOf('/');\n    if (end <= start) return null;\n    const patternStr = value.slice(start, end);\n    const flags = value.slice(end + 1);\n    try {\n        return new RegExp(patternStr, flags);\n    } catch (e) {\n        return null;\n    }\n}\n\n// Tokenize\nfunction tokenize(text) {\n    const tokens = [];\n    for (let i = 0, len = text.length; i < len;) {\n        let c = text[i];\n        if (c <= ' ') { i++; continue; }\n        if (c === '/') {\n            if (text[i + 1] === '/') { i = (text.indexOf('\\n', i + 2) + 1) || len; continue; }\n            if (text[i + 1] === '*') { i = ((text.indexOf('*/', i + 2) + 1) || len + 1); continue; }\n        } else if ('[]{}:;,'.includes(c)) { tokens.push(c); i++; continue; }\n        else if (c === '=') {\n            tokens.push('=');\n            i++;\n            let slashPos = text.indexOf('/', i);\n            if (slashPos > i && slashPos < i + 8) {\n                const regexMatch = text.slice(i).match(/^(?:regex:|re:|[:$])\\/.*?(?:\\/[a-z]*)?(?=[\\s\\]\\},;]|$)/i);\n                if (regexMatch) { tokens.push(regexMatch[0]); i += regexMatch[0].length; continue; }\n            }\n        }\n        const start = i;\n        while (i < len && text[i] > ' ' && !'[]{}:;,='.includes(text[i])) i++;\n        if (i > start) tokens.push(text.slice(start, i));\n    }\n    return tokens;\n}\n\n// Parse Rules\nfunction parseRules(text) {\n    const tokens = tokenize(text), rules = [];\n    for (let i = 0, len = tokens.length; i < len;) {\n        if (tokens[i] === '[') {\n            const groups = [[]];\n            try {\n                while (i < len && tokens[i] !== '{') {\n                    if (tokens[i] === '[') {\n                        const attr = tokens[++i]; i++;\n                        if (!attr) throw new Error('Missing attribute');\n                        let value = null, isRegex = false;\n                        if (tokens[i] === '=') {\n                            value = tokens[++i]; i++;\n                            const rx = parseRegex(value);\n                            if (rx) { value = rx; isRegex = true; }\n                        } else if (!attr.startsWith('query.')) throw new Error('Expected \"=\"');\n                        if (tokens[i++] !== ']') throw new Error('Missing \"]\"');\n                        groups[groups.length - 1].push({ attr, value, isRegex });\n                    } else if (tokens[i] === ',') {\n                        groups.push([]);\n                        i++;\n                    } else throw new Error('Invalid selector');\n                }\n                if (tokens[i++] !== '{') throw new Error('Missing \"{\"');\n                const features = {};\n                while (i < len && tokens[i] !== '}') {\n                    const name = tokens[i++], colon = tokens[i++], value = tokens[i++], semi = tokens[i++];\n                    if (colon !== ':' || semi !== ';') throw new Error('Invalid feature');\n                    features[name] = value;\n                }\n                if (tokens[i++] !== '}') throw new Error('Missing \"}\"');\n                rules.push({ selectors: groups.filter(g => g.length), features });\n            } catch (e) {\n                while (i < len && tokens[i] !== '[') i++;\n            }\n        } else i++;\n    }\n    return rules;\n}\n\n// Match Condition\nfunction matchCondition({ attr, value, isRegex }, { host, pathname, searchParams }) {\n    if (attr === 'host') return isRegex ? value.test(host) : matchGlob(value, host);\n    if (attr === 'path') return isRegex ? value.test(pathname) : matchGlob(value, pathname);\n    if (attr === 'domain') {\n        const domain = host.split('.').slice(-2).join('.');\n        return isRegex ? value.test(host) : matchGlob(value, domain);\n    }\n    if (attr.startsWith('query.')) {\n        const param = searchParams.get(attr.slice(6));\n        return value === null ? param !== null : param && (isRegex ? value.test(param) : matchGlob(value, param));\n    }\n    return false;\n}\n\n// Apply Rules\nfunction getFeatureValues(rules, urlObj) {\n    const features = {};\n    for (const rule of rules) {\n        if (rule.selectors.some(group => group.every(cond => matchCondition(cond, urlObj)))) {\n            Object.assign(features, rule.features);\n        }\n    }\n    return features;\n}\n\n// Export as ES Module\nexport function getWfrFeatures(text, url) {\n    try {\n        const urlObj = new URL(url);\n        return getFeatureValues(parseRules(text), urlObj);\n    } catch (_) {\n        return {};\n    }\n}"],"names":["tokenPatterns","tokenTypes","tokenize","text","tokens","pos","state","slice","matched","type","pattern","shouldProcessToken","match","updateState","REGEX_INTERNAL_PATTERNS","tokenizeRegexPattern","stack","top","content","pat","renderRegexPattern","fragment","openingSlash","patternText","flag","hasClosingSlash","inner","token","span","closingSlash","flagSpan","tokensToFragment","className","highlight","editor","code","error","matchGlob","p","s","firstWild","n","m","i","j","c","x","end","parseRegex","value","offset","start","patternStr","flags","e","len","slashPos","regexMatch","parseRules","rules","groups","attr","isRegex","rx","features","name","colon","semi","g","matchCondition","host","pathname","searchParams","domain","param","getFeatureValues","urlObj","rule","group","cond","getWfrFeatures","url","_"],"mappings":"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"}